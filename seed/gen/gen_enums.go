// Copyright 2022 Daniel Erat.
// All rights reserved.

package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"time"
	"unicode"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"golang.org/x/text/runes"
	"golang.org/x/text/transform"
	"golang.org/x/text/unicode/norm"
)

const (
	repoURL     = "https://raw.githubusercontent.com/metabrainz/musicbrainz-server/master/"
	dstPath     = "enums.go" // called from parent dir
	licensePath = "COPYING-enums.md"
	commentLen  = 80 - 4 // account for "\t// "
)

type enumTypes struct {
	types []*enumType
}

func (ets *enumTypes) add(et *enumType) *enumType {
	ets.types = append(ets.types, et)
	return et
}

type enumType struct {
	Name    string   // enum type name
	Type    string   // Go type
	Comment []string // multiline comment before declaration
	Values  []enumValue
	sort    bool // sort values by name
}

func (et *enumType) add(ev enumValue) { et.Values = append(et.Values, ev) }

type enumValue struct {
	Name    string   // enumType.name and underscore will be prepended
	Value   string   // literal value, i.e. quoted if string
	Comment []string // multiline comment before declaration
	EOL     string   // end-of-line comment
}

func main() {
	now := time.Now().UTC()
	var enums enumTypes
	var urls []string

	open := func(p string) (io.ReadCloser, error) {
		url := repoURL + p
		urls = append(urls, url)

		// Support reading from a file to make development easier.
		if len(os.Args) == 2 {
			return os.Open(filepath.Join(os.Args[1], p))
		}
		resp, err := http.Get(url)
		if err != nil {
			return nil, err
		}
		if resp.StatusCode != 200 {
			resp.Body.Close()
			return nil, fmt.Errorf("got %v for %v: %v", resp.StatusCode, url, resp.Status)
		}
		return resp.Body, nil
	}

	for _, src := range []struct {
		path string
		fn   func(io.Reader, *enumTypes) error
	}{
		{"t/sql/initial.sql", readSQL},
		{"po/languages.pot", readLangs},
		{"po/attributes.pot", readAttrs},
	} {
		if r, err := open(src.path); err != nil {
			log.Fatalf("Failed opening %v: %v", src.path, err)
		} else {
			defer r.Close()
			if err := src.fn(r, &enums); err != nil {
				log.Fatalf("Failed reading %v: %v", src.path, err)
			}
		}
	}

	// Sort enums by name and then values if requested.
	sort.Slice(enums.types, func(i, j int) bool {
		return enums.types[i].Name < enums.types[j].Name
	})
	for _, et := range enums.types {
		if et.sort {
			sort.Slice(et.Values, func(i, j int) bool { return et.Values[i].Name < et.Values[j].Name })
		}
	}
	sort.Strings(urls)

	// Write the file.
	tmpl, err := template.New("").Parse(fileTemplate)
	if err != nil {
		log.Fatal(err)
	}
	f, err := os.Create(dstPath)
	if err != nil {
		log.Fatal(err)
	}
	if err := tmpl.Execute(f, struct {
		License string
		Time    string
		URLs    []string
		Enums   []*enumType
	}{
		License: licensePath,
		Time:    now.Format("2006-01-02 15:04:05 MST"),
		URLs:    urls,
		Enums:   enums.types,
	}); err != nil {
		f.Close()
		log.Fatal(err)
	}
	if err := f.Close(); err != nil {
		log.Fatal(err)
	}

	// Format the file.
	if err := exec.Command("gofmt", "-w", dstPath).Run(); err != nil {
		log.Fatal(err)
	}
}

const fileTemplate = `
// This file is derived from https://github.com/metabrainz/musicbrainz-server,
// which is licensed under GNU General Public License (GPL) Version 2 or later.
// This license is located at {{.License}}.

package seed

// This file was automatically generated from the following files,
// downloaded at {{.Time}}:
{{range .URLs -}}
//  {{.}}
{{end -}}
// It can be regenerated by running "go generate".

{{range .Enums}}
{{range .Comment -}}
// {{.}}
{{end -}}
type {{.Name}} {{.Type}}

const (
{{$en := .Name}}{{range .Values -}}
{{range .Comment -}}
// {{.}}
{{end -}}
{{$en}}_{{.Name}} {{$en}} = {{.Value}}{{if .EOL}} // {{.EOL}}{{end}}
{{end -}}
)
{{end}}
`

// readSQL adds enums from the passed-in initial.sql file.
func readSQL(r io.Reader, enums *enumTypes) error {
	linkAttrTypes := enums.add(&enumType{
		Name: "LinkAttributeType",
		Type: "int",
		Comment: wrap(
			`LinkAttributeType is an ID describing an attribute associated with a link `+
				`between two MusicBrainz entities.`, commentLen),
	})
	linkTypes := enums.add(&enumType{
		Name: "LinkType",
		Type: "int",
		Comment: wrap(
			`LinkType is an ID describing a link between two MusicBrainz entities. `+
				`It sadly doesn't appear to enumerate all possible values. There are 170-ish `+
				`additional link types with translations in po/relationships.pot, many of `+
				`which don't appear to be referenced anywhere else in the server repo.`, commentLen),
		Values: []enumValue{
			// These IDs are listed in https://musicbrainz.org/recording/create and
			// https://musicbrainz.org/release/add, so presumably they're being used.
			// Comments are from po/relationships.pot.
			{
				Name:  "Crowdfunding_Recording_URL",
				Value: "905",
				Comment: wrap(
					"This links a recording to the relevant crowdfunding project at a "+
						"crowdfunding site like Kickstarter or Indiegogo.", commentLen),
			},
			{
				Name:  "Crowdfunding_Release_URL",
				Value: "906",
				Comment: wrap(
					"This links a release to the relevant crowdfunding project at a crowdfunding "+
						"site like Kickstarter or Indiegogo.", commentLen),
			},
			{
				Name:  "StreamingPaid_Recording_URL",
				Value: "979",
				Comment: wrap(
					"This relationship type is used to link a track to a site where the track can "+
						"be legally streamed for a subscription fee, e.g. Tidal. "+
						"If the site allows free streaming, use \"free streaming\" instead.", commentLen),
			},
			{
				Name:  "StreamingPaid_Release_URL",
				Value: "980",
				Comment: wrap(
					"This relationship type is used to link a release to a site where the tracks "+
						"can be legally streamed for a subscription fee, e.g. Tidal.", commentLen),
			},
		},
		sort: true,
	})
	mediumFormats := enums.add(&enumType{
		Name:    "MediumFormat",
		Type:    "string",
		Comment: wrap(`MediumFormat describes a medium's format (e.g. CD, cassette, digital media).`, commentLen),
	})
	releaseGroupTypes := enums.add(&enumType{
		Name: "ReleaseGroupType",
		Type: "string",
		Comment: wrap(
			`ReleaseGroupType describes a release group. `+
				`A release group can be assigned a single primary type and multiple secondary types.`, commentLen),
	})
	releasePackagings := enums.add(&enumType{
		Name:    "ReleasePackaging",
		Type:    "string",
		Comment: wrap("ReleasePackaging describes a release's packaging.", commentLen),
	})
	releaseStatuses := enums.add(&enumType{
		Name:    "ReleaseStatus",
		Type:    "string",
		Comment: wrap("ReleaseStatus describes a release's status.", commentLen),
	})
	workTypes := enums.add(&enumType{
		Name:    "WorkType",
		Type:    "int",
		Comment: wrap("WorkType describes a work's type.", commentLen),
		sort:    true,
	})

	// Process the SQL statements.
	var stringErr error
	sc := bufio.NewScanner(r)
	for sc.Scan() {
		ln := sc.Text()
		if !insertStartRegexp.MatchString(ln) {
			continue
		}

		table, vals, err := parseInsert(ln)
		if err != nil {
			return fmt.Errorf("%q: %v", ln, err)
		}

		stringVal := func(i int) string {
			if stringErr != nil {
				return ""
			}
			if i > len(vals) {
				stringErr = fmt.Errorf("bad value index %d from %q", i, ln)
				return ""
			}
			switch v := vals[i].(type) {
			case string:
				return v
			case nil:
				return ""
			default:
				stringErr = fmt.Errorf("non-string type %T at %d in %q", v, i, ln)
				return ""
			}
		}

		// The below schema definitions come from
		// https://raw.githubusercontent.com/metabrainz/musicbrainz-server/master/admin/sql/CreateTables.sql.
		switch table {
		case "link_attribute_type":
			//  CREATE TABLE link_attribute_type ( -- replicate
			//  	id                  SERIAL,
			//  	parent              INTEGER, -- references link_attribute_type.id
			//  	root                INTEGER NOT NULL, -- references link_attribute_type.id
			//  	child_order         INTEGER NOT NULL DEFAULT 0,
			//  	gid                 UUID NOT NULL,
			//  	name                VARCHAR(255) NOT NULL,
			//  	description         TEXT,
			//  	last_updated        TIMESTAMP WITH TIME ZONE DEFAULT NOW()
			//  );
			linkAttrTypes.add(enumValue{
				Name:    clean(stringVal(5)),
				Value:   strconv.Itoa(vals[0].(int)),
				Comment: wrap(stringVal(6), commentLen),
			})
		case "link_type":
			//  CREATE TABLE link_type ( -- replicate
			//  	id                  SERIAL,
			//  	parent              INTEGER, -- references link_type.id
			//  	child_order         INTEGER NOT NULL DEFAULT 0,
			//  	gid                 UUID NOT NULL,
			//  	entity_type0        VARCHAR(50) NOT NULL,
			//  	entity_type1        VARCHAR(50) NOT NULL,
			//  	name                VARCHAR(255) NOT NULL,
			//  	description         TEXT,
			//  	link_phrase         VARCHAR(255) NOT NULL,
			//  	reverse_link_phrase VARCHAR(255) NOT NULL,
			//  	long_link_phrase    VARCHAR(255) NOT NULL,
			//  	priority            INTEGER NOT NULL DEFAULT 0,
			//  	last_updated        TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
			//  	is_deprecated       BOOLEAN NOT NULL DEFAULT false,
			//  	has_dates           BOOLEAN NOT NULL DEFAULT true,
			//  	entity0_cardinality SMALLINT NOT NULL DEFAULT 0,
			//  	entity1_cardinality SMALLINT NOT NULL DEFAULT 0
			//  );
			id, name := vals[0].(int), stringVal(6)
			switch id {
			case 184:
				// 171 and 184 are both named "discography" and map from Artists to URLs.
				// 184 lists 171 as its parent, and some of the translations call it
				// "discography page", so rename it to that to prevent a conflict.
				name = "discography page"
			}
			linkTypes.add(enumValue{
				// If this format is changed, the hardcoded entries in linkTypes need to be updated.
				Name:    fmt.Sprintf("%s_%s_%s", clean(name), clean(stringVal(4)), clean(stringVal(5))),
				Value:   strconv.Itoa(id),
				Comment: wrap(stringVal(7), commentLen),
			})
		case "medium_format":
			//  CREATE TABLE medium_format ( -- replicate
			//  	id                  SERIAL,
			//  	name                VARCHAR(100) NOT NULL,
			//  	parent              INTEGER, -- references medium_format.id
			//  	child_order         INTEGER NOT NULL DEFAULT 0,
			//  	year                SMALLINT,
			//  	has_discids         BOOLEAN NOT NULL DEFAULT FALSE,
			//  	description         TEXT,
			//  	gid                 uuid NOT NULL
			//  );
			mediumFormats.add(enumValue{
				Name:    clean(stringVal(1)),
				Value:   fmt.Sprintf("%q", stringVal(1)),
				Comment: wrap(stringVal(6), commentLen),
			})
		case "release_group_primary_type", "release_group_secondary_type":
			//  CREATE TABLE release_group_primary_type ( -- replicate
			//      id                  SERIAL,
			//      name                VARCHAR(255) NOT NULL,
			//      parent              INTEGER, -- references release_group_primary_type.id
			//      child_order         INTEGER NOT NULL DEFAULT 0,
			//      description         TEXT,
			//      gid                 uuid NOT NULL
			//  );
			//  CREATE TABLE release_group_secondary_type ( -- replicate
			//      id                  SERIAL NOT NULL, -- PK
			//      name                TEXT NOT NULL,
			//      parent              INTEGER, -- references release_group_secondary_type.id
			//      child_order         INTEGER NOT NULL DEFAULT 0,
			//      description         TEXT,
			//      gid                 uuid NOT NULL
			//  );
			eol := "primary"
			if table == "release_group_secondary_type" {
				eol = "secondary"
			}
			releaseGroupTypes.add(enumValue{
				Name:  clean(stringVal(1)),
				Value: fmt.Sprintf("%q", stringVal(1)),
				EOL:   eol,
			})
		case "release_packaging":
			//  CREATE TABLE release_packaging ( -- replicate
			//  	id                  SERIAL,
			//  	name                VARCHAR(255) NOT NULL,
			//  	parent              INTEGER, -- references release_packaging.id
			//  	child_order         INTEGER NOT NULL DEFAULT 0,
			//  	description         TEXT,
			//  	gid                 uuid NOT NULL
			//  );
			releasePackagings.add(enumValue{
				Name:    clean(stringVal(1)),
				Value:   fmt.Sprintf("%q", stringVal(1)),
				Comment: wrap(stringVal(4), commentLen),
			})
		case "release_status":
			//  CREATE TABLE release_status ( -- replicate
			//  	id                  SERIAL,
			//  	name                VARCHAR(255) NOT NULL,
			//  	parent              INTEGER, -- references release_status.id
			//  	child_order         INTEGER NOT NULL DEFAULT 0,
			//  	description         TEXT,
			//  	gid                 uuid NOT NULL
			//  );
			releaseStatuses.add(enumValue{
				Name:    clean(stringVal(1)),
				Value:   fmt.Sprintf("%q", stringVal(1)),
				Comment: wrap(stringVal(4), commentLen),
			})
		case "work_type":
			//  CREATE TABLE work_type ( -- replicate
			//      id                  SERIAL,
			//      name                VARCHAR(255) NOT NULL,
			//      parent              INTEGER, -- references work_type.id
			//      child_order         INTEGER NOT NULL DEFAULT 0,
			//      description         TEXT,
			//      gid                 uuid NOT NULL
			//  );
			workTypes.add(enumValue{
				Name:    clean(stringVal(1)),
				Value:   strconv.Itoa(vals[0].(int)),
				Comment: wrap(stringVal(4), commentLen),
			})
		}
	}
	if err := sc.Err(); err != nil {
		return err
	}
	return stringErr
}

// wordMap contains words with specialized capitalization.
var wordMap = map[string]string{
	"8cm":          "8cm",
	"allmusic":     "AllMusic",
	"asin":         "ASIN",
	"bookbrainz":   "BookBrainz",
	"cd":           "CD",
	"cdv":          "CDV",
	"ced":          "CED",
	"dat":          "DAT",
	"dcc":          "DCC",
	"dj":           "DJ",
	"dts":          "DTS",
	"dualdisc":     "DualDisc",
	"dvdaudio":     "DVDAudio",
	"dvd":          "DVD",
	"dvdplus":      "DVDplus",
	"dvdvideo":     "DVDVideo",
	"ep":           "EP",
	"hdcd":         "HDCD",
	"hd":           "HD",
	"hqcd":         "HQCD",
	"imdb":         "IMDB",
	"imslp":        "IMSLP",
	"laserdisc":    "LaserDisc",
	"minidisc":     "MiniDisc",
	"prs":          "PRS",
	"releasegroup": "ReleaseGroup",
	"sacd":         "SACD",
	"shm":          "SHM",
	"slotmusic":    "slotMusic",
	"svcd":         "SVCD",
	"umd":          "UMD",
	"url":          "URL",
	"usb":          "USB",
	"vcd":          "VCD",
	"vgmdb":        "VGMdb",
	"vhd":          "VHD",
	"vhs":          "VHS",
	"viaf":         "VIAF",
	"vinyldisc":    "VinylDisc",
	"youtube":      "YouTube",
}

var nonAlnumRegexp = regexp.MustCompile("[^a-zA-Z0-9]+")
var splitRegexp = regexp.MustCompile("[-+ /]+")

// https://go.dev/blog/normalization#performing-magic
var normalizer = transform.Chain(norm.NFKD, runes.Remove(runes.In(unicode.Mn)))

// normalize normalizes characters using NFKD form.
// Unicode characters are decomposed (runes are broken into their components) and replaced for
// compatibility equivalence (characters that represent the same characters but have different
// visual representations, e.g. '9' and '⁹', are equal). Characters are also de-accented.
func normalize(orig string) string {
	b := make([]byte, len(orig))
	if _, _, err := normalizer.Transform(b, []byte(orig), true); err != nil {
		return orig
	}
	return string(bytes.TrimRight(b, "\x00"))
}

// clean attempts to transform orig into a string that can be used in an identifier.
// Each word is capitalized.
func clean(orig string) string {
	var s string
	for _, w := range splitRegexp.Split(orig, -1) {
		w = strings.ToLower(normalize(w))
		w = nonAlnumRegexp.ReplaceAllString(strings.ToLower(w), "")
		if dst, ok := wordMap[w]; ok {
			w = dst
		} else {
			w = cases.Title(language.English, cases.Compact).String(w)
		}
		s += w
	}
	return s
}

const spaceChars = " \t"

// wrap attempts to wrap orig to lines with the supplied maximum length.
func wrap(orig string, max int) []string {
	var lines []string
	for _, rest := range strings.Split(strings.TrimSpace(orig), "\n") {
		rest = strings.TrimSpace(rest)
		for rest != "" {
			if len(rest) <= max {
				lines = append(lines, rest)
				break
			}
			if idx := strings.LastIndexAny(rest[:max+1], spaceChars); idx >= 0 {
				lines = append(lines, strings.TrimSpace(rest[:idx]))
				rest = strings.TrimSpace(rest[idx:])
			} else if idx := strings.IndexAny(rest[max:], spaceChars); idx >= 0 {
				lines = append(lines, rest[:max+idx])
				rest = strings.TrimSpace(rest[max+idx:])
			} else {
				lines = append(lines, rest)
				break
			}
		}
	}
	return lines
}

// insertStartRegexp is just used to identify lines that contain SQL INSERT statements.
var insertStartRegexp = regexp.MustCompile(`^\s*INSERT\s+INTO\s+[_a-z]+\s+VALUES`)

// parseInsert parses a SQL INSERT statement into its table name and inserted values.
//
// PostgreSQL's grammar is quite complex:
//  https://www.postgresql.org/docs/current/sql-insert.html
//  https://www.postgresql.org/docs/current/sql-syntax-lexical.html
//  etc.
//
// This function only understands enough of it to process
// https://raw.githubusercontent.com/metabrainz/musicbrainz-server/master/t/sql/initial.sql.
func parseInsert(stmt string) (table string, vals []interface{}, err error) {
	ms := insertRegexp.FindStringSubmatch(stmt)
	if ms == nil {
		return "", nil, errors.New("failed parsing statement")
	}
	table = ms[1]
	list := strings.TrimSpace(ms[2])

	for list != "" {
		ch := list[0]
		switch {
		case ch == '\'' || ch == 'E' || ch == 'e':
			if v, n, err := readString(list, ch != '\''); err != nil {
				return table, vals, err
			} else {
				vals = append(vals, v)
				list = list[n:]
			}
		case numRegexp.MatchString(list):
			s := numRegexp.FindString(list)
			if strings.Index(s, ".") != -1 {
				if v, err := strconv.ParseFloat(s, 64); err != nil {
					return table, vals, err
				} else {
					vals = append(vals, v)
				}
			} else {
				if v, err := strconv.ParseInt(s, 10, 64); err != nil {
					return table, vals, err
				} else {
					vals = append(vals, int(v))
				}
			}
			list = list[len(s):]
		case strings.HasPrefix(list, "NULL"):
			vals = append(vals, nil)
			list = list[4:]
		case strings.HasPrefix(list, "true"):
			vals = append(vals, true)
			list = list[4:]
		case strings.HasPrefix(list, "false"):
			vals = append(vals, false)
			list = list[5:]
		default:
			return table, vals, fmt.Errorf("unhandled value at start of %q", list)
		}

		list = strings.TrimSpace(list)
		list = strings.TrimPrefix(list, ",")
		list = strings.TrimSpace(list)
	}

	return table, vals, nil
}

// insertRegexp (poorly) matches a SQL INSERT statement of the form
// "INSERT INTO table_name VALUES (...);". The first match group contains
// the table name and the second match group contains the values list.
var insertRegexp = regexp.MustCompile(`^\s*INSERT\s+INTO\s+([^\s]+)\s+VALUES\s*\((.*)\)\s*` +
	`(?:ON\s+CONFLICT\s*\([^)]+\)\s*DO\s+NOTHING\s*)?;\s*$`)

// numRegexp matches a subset of the numeric constant forms listed at
// https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-NUMERIC.
// It doesn't include the 'e' exponent marker, and it additional matches leading '-' or '+'
// characters even though in PostreSQL, "any leading plus or minus sign is not actually considered
// part of the constant; it is an operator applied to the constant."
var numRegexp = regexp.MustCompile(`^[-+]?(\d+|\d+\.\d*|\d*\.\d+)`)

// readString reads a quoted string (including surrounding single-quotes) at the beginning of in.
// It returns the unquoted string and the number of characters consumed.
func readString(in string, bsEsc bool) (string, int, error) {
	var v strings.Builder
	var inEscape bool
	for i := 0; i < len(in); i++ {
		ch := in[i]
		switch {
		case (!bsEsc && i == 0) || (bsEsc && i == 1):
			if ch != '\'' {
				return "", 0, errors.New("no starting quote")
			}
		case bsEsc && i == 0:
			if ch != 'E' && ch != 'e' {
				return "", 0, errors.New("no starting 'e' or 'E'")
			}
		case inEscape:
			if bsEsc {
				switch ch {
				case 'n':
					v.WriteRune('\n')
				case 'r':
					v.WriteRune('\r')
				case 't':
					v.WriteRune('\t')
				default:
					v.WriteByte(ch)
				}
			} else {
				v.WriteByte(ch)
			}
			inEscape = false
		case ch == '\'':
			if i < len(in)-1 && in[i+1] == '\'' {
				inEscape = true
			} else {
				return v.String(), i + 1, nil
			}
		case ch == '\\' && bsEsc:
			inEscape = true
		default:
			// Add this as a byte rather than a rune to avoid messing up multibyte chars.
			v.WriteByte(ch)
		}
	}
	return "", 0, errors.New("no ending quote")
}

// readLangs adds enums from the passed-in languages.pot file.
func readLangs(r io.Reader, enums *enumTypes) error {
	langs := enums.add(&enumType{
		Name: "Language",
		Type: "int",
		Comment: wrap(`Language represents a human language. `+
			`These values correspond to integer IDs in the database; `+
			`note that some fields (most notably Release.Language) `+
			`confusingly use ISO 639-3 codes instead.`, commentLen),
		sort: true,
	})

	entries, err := readPOFile(r)
	if err != nil {
		return err
	}
	for _, entry := range entries {
		if entry.ref == "DB:language/name" {
			langs.add(enumValue{
				Name:  clean(langCleanRegexp.ReplaceAllString(entry.msg, "")),
				Value: entry.id,
				EOL:   entry.msg,
			})
		}
	}
	return nil
}

var langCleanRegexp = regexp.MustCompile(`\s*\([^)]*\d[^)]*\)$`) // trailing parentheticals containing numbers

// readAttrs adds enums from the passed-in attributes.pot file.
func readAttrs(r io.Reader, enums *enumTypes) error {
	workAttrTypes := enums.add(&enumType{
		Name:    "WorkAttributeType",
		Type:    "int",
		Comment: wrap(`WorkAttributeType describes an attribute attached to a work.`, commentLen),
		sort:    true,
	})

	entries, err := readPOFile(r)
	if err != nil {
		return err
	}
	for _, entry := range entries {
		if entry.ref == "DB:work_attribute_type/name" {
			// Most names are full of acronyms like "AGADU ID" or "AKKA/LAA ID".
			// Preserve these in names ending in " ID".
			name := entry.msg
			if strings.HasSuffix(name, " ID") {
				name = normalize(name) // needed for "MÜST ID"
				name = nonAlnumRegexp.ReplaceAllString(name, "_")
			} else {
				name = clean(name)
			}
			workAttrTypes.add(enumValue{
				Name:  name,
				Value: entry.id,
				EOL:   entry.msg,
			})
		}
	}
	return nil
}

// readPOFile reads the passed-in PO file.
// See https://www.gnu.org/software/gettext/manual/html_node/PO-Files.html.
func readPOFile(r io.Reader) ([]poEntry, error) {
	var entries []poEntry
	sc := bufio.NewScanner(r)
	var ref, id string
	for sc.Scan() {
		ln := sc.Text()
		if ms := poRefRegexp.FindStringSubmatch(ln); ms != nil {
			ref, id = ms[1], ms[2]
		} else if ms := poMsgIDRegexp.FindStringSubmatch(ln); ms != nil {
			if id == "" {
				return entries, fmt.Errorf("no ID for msgid %q", ms[1])
			}
			entries = append(entries, poEntry{ref, id, ms[1]})
			ref = ""
			id = ""
		}
	}
	return entries, sc.Err()
}

// poEntry describes an entry from a PO translation file.
type poEntry struct {
	ref string // e.g. "DB:language/name" or "DB:work_attribute_type/name"
	id  string // e.g. "123"
	msg string // untranslated string
}

var poRefRegexp = regexp.MustCompile(`^#: (.+):(.+)$`)
var poMsgIDRegexp = regexp.MustCompile(`^msgid "(.+)"$`)
