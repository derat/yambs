// Copyright 2022 Daniel Erat.
// All rights reserved.

package main

import (
	"bufio"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"time"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

//go:generate go run gen_enums.go

const (
	sqlURL      = "https://raw.githubusercontent.com/metabrainz/musicbrainz-server/master/t/sql/initial.sql"
	dstPath     = "seed/enums.go"
	licensePath = "seed/COPYING-enums.md"
	commentLen  = 80 - 4 // account for "\t// "
)

func main() {
	now := time.Now().UTC()
	resp, err := http.Get(sqlURL)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		log.Fatalf("Got non-200 status code %v: %v", resp.StatusCode, resp.Status)
	}

	var linkTypes []linkType

	sc := bufio.NewScanner(resp.Body)
	for sc.Scan() {
		if ms := linkTypeRegexp.FindStringSubmatch(sc.Text()); ms != nil {
			id, err := strconv.Atoi(ms[1])
			if err != nil {
				log.Fatal(err)
			}
			type1 := ms[2]
			type2 := ms[3]
			name := ms[4]
			if custom, ok := customLinkTypeNames[id]; ok {
				name = custom
			}
			desc := ms[5]

			linkTypes = append(linkTypes, linkType{
				ID: id,
				// If this format is changed, extraLinkTypes needs to be updated.
				Name:         fmt.Sprintf("%s_%s_%s_Link", clean(name), clean(type1), clean(type2)),
				CommentLines: wrap(desc, commentLen),
			})
		}
	}
	if sc.Err() != nil {
		log.Fatal(sc.Err())
	}

	linkTypes = append(linkTypes, extraLinkTypes...)
	sort.Slice(linkTypes, func(i, j int) bool { return linkTypes[i].Name < linkTypes[j].Name })

	tmpl, err := template.New("").Parse(fileTemplate)
	if err != nil {
		log.Fatal(err)
	}
	f, err := os.Create(dstPath)
	if err != nil {
		log.Fatal(err)
	}
	if err := tmpl.Execute(f, struct {
		License   string
		Time      string
		URL       string
		LinkTypes []linkType
	}{
		License:   licensePath,
		Time:      now.Format("2006-01-02 15:04:05 MST"),
		URL:       sqlURL,
		LinkTypes: linkTypes,
	}); err != nil {
		f.Close()
		log.Fatal(err)
	}
	if err := f.Close(); err != nil {
		log.Fatal(err)
	}

	if err := exec.Command("gofmt", "-w", dstPath).Run(); err != nil {
		log.Fatal(err)
	}
}

const fileTemplate = `
// This file is derived from https://github.com/metabrainz/musicbrainz-server,
// which is licensed under GNU General Public License (GPL) Version 2 or later.
// This license is located at {{.License}}.

package seed

// This file was automatically generated from a copy of
// {{.URL}}
// downloaded at {{.Time}}.
// It can be regenerated by running "go generate".

// LinkType is an ID describing a link between two MusicBrainz entities.
// It sadly doesn't appear to enumerate all possible values. There are 173
// additional link types with translations in po/relationships.pot, many of
// which don't appear to be referenced anywhere else in the server repo.
type LinkType int

const (
{{range .LinkTypes -}}
{{range .CommentLines -}}
// {{.}}
{{end -}}
{{.Name}} LinkType = {{.ID}}
{{end -}}
)
`

var nonAlnumRegexp = regexp.MustCompile("[^a-z0-9]+")
var splitRegexp = regexp.MustCompile("[- ]+")

// wordMap contains words with specialized capitalization.
var wordMap = map[string]string{
	"allmusic":     "AllMusic",
	"asin":         "ASIN",
	"bookbrainz":   "BookBrainz",
	"dj":           "DJ",
	"imdb":         "IMDB",
	"imslp":        "IMSLP",
	"releasegroup": "ReleaseGroup",
	"url":          "URL",
	"vgmdb":        "VGMdb",
	"viaf":         "VIAF",
	"youtube":      "YouTube",
}

// clean attempts to transform orig into a string that can be used in an identifier.
// Each word is capitalized.
func clean(orig string) string {
	var s string
	for _, w := range splitRegexp.Split(orig, -1) {
		w = nonAlnumRegexp.ReplaceAllString(strings.ToLower(w), "")
		if dst, ok := wordMap[w]; ok {
			w = dst
		} else {
			w = cases.Title(language.English, cases.Compact).String(w)
		}
		s += w
	}
	return s
}

const spaceChars = " "

// wrap attempts to wrap orig to lines with the supplied maximum length.
func wrap(orig string, max int) []string {
	var lines []string
	rest := strings.TrimSpace(orig)
	for rest != "" {
		if len(rest) <= max {
			lines = append(lines, rest)
			break
		}
		if idx := strings.LastIndexAny(rest[:max+1], spaceChars); idx >= 0 {
			lines = append(lines, strings.TrimSpace(rest[:idx]))
			rest = strings.TrimSpace(rest[idx:])
		} else if idx := strings.IndexAny(rest[max:], spaceChars); idx >= 0 {
			lines = append(lines, rest[:max+idx])
			rest = strings.TrimSpace(rest[max+idx:])
		} else {
			lines = append(lines, rest)
			break
		}
	}
	return lines
}

// https://raw.githubusercontent.com/metabrainz/musicbrainz-server/master/admin/sql/CreateTables.sql
//
// CREATE TABLE link_type ( -- replicate
// 	id                  SERIAL,
// 	parent              INTEGER, -- references link_type.id
// 	child_order         INTEGER NOT NULL DEFAULT 0,
// 	gid                 UUID NOT NULL,
// 	entity_type0        VARCHAR(50) NOT NULL,
// 	entity_type1        VARCHAR(50) NOT NULL,
// 	name                VARCHAR(255) NOT NULL,
// 	description         TEXT,
// 	link_phrase         VARCHAR(255) NOT NULL,
// 	reverse_link_phrase VARCHAR(255) NOT NULL,
// 	long_link_phrase    VARCHAR(255) NOT NULL,
// 	priority            INTEGER NOT NULL DEFAULT 0,
// 	last_updated        TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
// 	is_deprecated       BOOLEAN NOT NULL DEFAULT false,
// 	has_dates           BOOLEAN NOT NULL DEFAULT true,
// 	entity0_cardinality SMALLINT NOT NULL DEFAULT 0,
// 	entity1_cardinality SMALLINT NOT NULL DEFAULT 0
// );

var linkTypeRegexp = regexp.MustCompile(
	`(?i)^\s*INSERT\s+INTO\s+link_type\s+VALUES\s*\(` +
		`\s*(\d+)\s*,` + // 'id' (group 1)
		`[^,]+,` + // 'parent'
		`[^,]+,` + // 'child_order'
		`[^,]+,` + // 'gid' (MBID)
		`\s*'([^']*)'\s*,` + // 'entity_type0' (group 2)
		`\s*'([^']*)'\s*,` + // 'entity_type1' (group 3)
		`\s*'([^']*)'\s*,` + // 'name' (group 4)
		`\s*'([^']*)'\s*,` + // 'description' (group 5)
		`.*`)

// linkType describes a seed.LinkType enum value.
type linkType struct {
	ID           int
	Name         string
	CommentLines []string
}

// customLinkTypes maps from link type IDs to custom names that
// should be used for them.
var customLinkTypeNames = map[int]string{
	// 171 and 184 are both named "discography" and map from Artists to URLs.
	// 184 lists 171 as its parent, and some of the translations call it
	// "discography page", so rename it to that to prevent a conflict.
	184: "discography page",
}

// extraLinkTypes adds extra types that are missing from the SQL file.
var extraLinkTypes = []linkType{
	// These IDs are listed in https://musicbrainz.org/release/add, so presumably they're
	// being used. Comments are from po/relationships.pot.
	{729, "ShowNotes_Release_URL_Link", nil},
	{906, "Crowdfunding_Release_URL_Link", wrap(
		"This links a release to the relevant crowdfunding project at a crowdfunding "+
			"site like Kickstarter or Indiegogo.", commentLen),
	},
	{980, "StreamingPaid_Release_URL_Link", wrap(
		"This relationship type is used to link a release to a site where the tracks "+
			"can be legally streamed for a subscription fee, e.g. Tidal.", commentLen),
	},
}
