<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <title>yambs</title>
    <style>
      :root {
        --border-color: #ccc;
        --header-color: #eee;
        --link-color: #444;
        --margin: 8px;
      }
      body {
        font-family: Roboto, Arial, Helvetica, sans-serif;
        font-size: 14px;
      }
      h1 {
        font-size: 20px;
        margin-bottom: var(--margin);
      }
      h2 {
        font-size: 16px;
        margin-bottom: var(--margin);
      }

      .button-container {
        display: flex;
        gap: var(--margin);
        margin-top: var(--margin);
      }

      #edit-section {
        display: none;
      }
      #edit-section.visible {
        display: block;
      }

      #edit-table {
        border: solid 1px var(--border-color);
        border-collapse: collapse;
      }
      #edit-table th {
        background-color: var(--header-color);
      }
      #edit-table td,
      #edit-table th {
        border: solid 1px var(--border-color);
        text-align: left;
      }
      #edit-table th:nth-child(2),
      #edit-table td:nth-child(2) {
        /* This is hacky; table layout is a disaster. */
        max-width: calc(100vw - 100px);
        overflow: hidden;
        padding: 0 var(--margin);
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      #edit-table a {
        color: var(--link-color);
        cursor: pointer;
        text-decoration: underline;
      }
      #edit-header-checkbox.partial {
        opacity: 0.4;
      }

      #edit-opening-overlay {
        align-items: center;
        backdrop-filter: blur(1px);
        background-color: #0002;
        display: none;
        font-size: 20px;
        height: 100vh;
        justify-content: center;
        left: 0;
        position: fixed;
        top: 0;
        width: 100vw;
        z-index: 1;
      }
      #edit-opening-overlay.visible {
        display: flex;
      }
    </style>
  </head>
  <body>
    <h1>yambs</h1>

    <div id="edit-section">
      <h2>Seeded MusicBrainz edits</h2>
      <table id="edit-table">
        <thead>
          <tr>
            <th><input id="edit-header-checkbox" type="checkbox" /></th>
            <th>Edit</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="button-container">
        <button id="edit-open-all-button">Open all</button>
        <button id="edit-open-selected-button">Open selected</button>
      </div>
    </div>
    <div id="edit-opening-overlay">Opening editâ€¦</div>
  </body>
  <!-- prettier-ignore -->
  <script>
    // This confuses Prettier and seemingly can't be ignored with "// prettier-ignore",
    // so put it in its own script element.
    const initialEdits = [
      {{- range .Edits}}
      {
        desc: {{.Desc}},
        url: {{.URL}},
        params: [
          {{- range .Params}}
          [{{.Name}}, {{.Value}}],
          {{- end}}
        ],
      },
      {{- end}}
    ];
  </script>
  <script>
    const $ = (id) => document.getElementById(id);

    function createElement(type, parentElement = null, className = null, text = null) {
      const element = document.createElement(type);
      if (parentElement) parentElement.appendChild(element);
      if (className) element.className = className;
      if (text || text === '') element.appendChild(document.createTextNode(text));
      return element;
    }

    const editPreselect = 5; // number of checkboxes to automatically select
    const editSection = $('edit-section');
    const editHeaderCheckbox = $('edit-header-checkbox');
    const editOpenAllButton = $('edit-open-all-button');
    const editOpenSelButton = $('edit-open-selected-button');
    const editTable = $('edit-table');
    const editCheckboxes = [];
    const editForms = []; // null for GETs
    const editLinks = [];
    let editLastClickIndex = -1; // index of last-clicked edit checkbox

    // Returns a 2-element array with the starting and ending index of the selection range.
    // If there isn't a single range, null is returned.
    function getEditSelectionRange() {
      let start = -1;
      let end = -1;
      for (const [idx, cb] of editCheckboxes.entries()) {
        if (!cb.checked) continue;
        if (start < 0) start = end = idx;
        else if (end === idx - 1) end = idx;
        else return null; // not a continuous range
      }
      return start < 0 ? null : [start, end];
    }

    // Returns the number of selected edit rows.
    const getNumSelectedEdits = () => editCheckboxes.filter((cb) => cb.checked).length;

    // If a continuous range of n rows is selected, advances the selection to the next n rows.
    function advanceEditSelection() {
      const range = getEditSelectionRange();
      if (!range || range[1] === editLinks.length - 1) return;

      const start = range[1] + 1;
      const end = start + (range[1] - range[0] + 1);
      editCheckboxes.forEach((cb, idx) => (cb.checked = idx >= start && idx <= end));
      updateEditState();
    }

    // Updates edit header checkbox state and buttons for the currently-checked checkboxes.
    function updateEditState() {
      editOpenAllButton.disabled = editLinks.length === 0;

      // Update the "Open selected" button's text and disabled state.
      const range = getEditSelectionRange();
      editOpenSelButton.innerText =
        range && range[1] < editLinks.length - 1 ? 'Open selected and advance' : 'Open selected';
      editOpenSelButton.disabled = getNumSelectedEdits() === 0;

      // Make the header checkbox checked if any rows are selected, and translucent if only some of
      // the rows are selected.
      const count = getNumSelectedEdits();
      editHeaderCheckbox.checked = count > 0;
      const partial = count > 0 && count < editCheckboxes.length;
      if (partial) editHeaderCheckbox.classList.add('partial');
      else editHeaderCheckbox.classList.remove('partial');
    }

    // Displays the supplied array of objects describing edits:
    // {
    //   desc: 'Human-readable description',
    //   url: 'https://www.example.org',          // includes params if GET is okay
    //   params: [['k', 'v1'], ['k', 'v2'], ...], // if non-empty, POST is needed
    // }
    function displayEdits(edits) {
      if (edits.length) editSection.classList.add('visible');
      else editSection.classList.remove('visible');

      const tbody = editTable.querySelector('tbody');
      while (tbody.firstChild) tbody.removeChild(tbody.lastChild);
      editCheckboxes.length = 0;
      editForms.length = 0;
      editLinks.length = 0;
      editLastClickIndex = -1;

      // Add a row for each edit.
      for (const [idx, edit] of edits.entries()) {
        const tr = createElement('tr', tbody);

        // Add a column containing a checkbox.
        const td1 = createElement('td', tr);
        const cb = createElement('input', td1);
        editCheckboxes.push(cb);
        cb.type = 'checkbox';
        cb.addEventListener('click', (e) => {
          // On shift-click, update the range starting at the last-clicked checkbox.
          if (e.shiftKey && editLastClickIndex >= 0 && editLastClickIndex != idx) {
            const checked = cb.checked;
            const start = Math.min(editLastClickIndex, idx);
            const end = Math.max(editLastClickIndex, idx);
            for (let i = start; i <= end; i++) editCheckboxes[i].checked = checked;
          }
          editLastClickIndex = idx;
          updateEditState();
        });
        if (idx < editPreselect) cb.checked = true;

        // Add a second column containing a link.
        // If this edit requires a POST, also add a form.
        const td2 = createElement('td', tr);
        if (edit.params && edit.params.length) {
          const form = createElement('form', td2);
          editForms.push(form);
          form.action = edit.url;
          form.method = 'post';
          form.target = '_blank';
          for (const p of edit.params) {
            const input = createElement('input', form);
            input.type = 'hidden';
            input.name = p[0];
            input.value = p[1];
          }
        } else {
          editForms.push(null);
        }

        const link = createElement('a', td2, null, edit.desc);
        editLinks.push(link);
        if (!edit.params || !edit.params.length) link.href = edit.url;
        link.target = '_blank';
        link.addEventListener('click', (e) => {
          // If there's a form (because this edit requires a POST), submit it.
          // Otherwise, just let the link perform its default action.
          const f = editForms[idx];
          if (f) {
            f.submit();
            e.preventDefault();
          }
        });
      }
    }

    // Initialize the page.
    (() => {
      // Initialize edit-related stuff.
      editHeaderCheckbox.addEventListener('click', () => {
        editLastClickIndex = -1;
        const empty = getNumSelectedEdits() === 0;
        editCheckboxes.forEach((cb) => (cb.checked = empty));
        updateEditState();
      });
      editOpenSelButton.addEventListener('click', () => {
        editLinks.filter((_, i) => editCheckboxes[i].checked).forEach((a) => a.click());
        advanceEditSelection();
      });
      editOpenAllButton.addEventListener('click', () => {
        for (const a of editLinks) a.click();
      });

      if (initialEdits.length) displayEdits(initialEdits);
      updateEditState();

      // If there's a single edit, just open it in the current window.
      if (editLinks.length === 1) {
        if (editForms[0]) editForms[0].target = '_self';
        editLinks[0].target = '_self';
        editLinks[0].click();
        $('opening-overlay').classList.add('visible');
      }
    })();
  </script>
</html>
