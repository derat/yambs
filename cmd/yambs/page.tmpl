<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <title>yambs</title>
    <style>
      :root {
        --border-color: #ccc;
        --header-color: #eee;
        --link-color: #444;
        --margin: 8px;
      }
      body {
        font-family: Roboto, Arial, Helvetica, sans-serif;
        font-size: 14px;
      }
      h1 {
        font-size: 20px;
        margin-bottom: var(--margin);
      }
      h2 {
        font-size: 16px;
        margin-bottom: var(--margin);
      }
      select {
        padding: 2px;
        margin-right: var(--margin);
      }
      input[type='text'] {
        padding: 2px 4px;
      }
      label:first-child {
        display: inline-block;
        min-width: 50px;
      }

      .section {
        display: none;
      }
      .section.visible {
        display: block;
      }

      .form-row {
        margin-bottom: var(--margin);
      }
      .button-row {
        display: flex;
        gap: var(--margin);
        margin-top: var(--margin);
      }

      #form-bandcamp-url-input {
        max-width: 100%;
        width: 400px;
      }
      #form-text-fields-input {
        display: block;
        max-width: 100%;
        width: 400px;
      }
      #form-text-set-textarea {
        display: block;
        max-width: 100%;
        height: 50px;
        width: 400px;
      }
      #form-text-input-textarea {
        display: block;
        max-width: 100%;
        height: 300px;
        width: 800px;
      }

      #edit-table {
        border: solid 1px var(--border-color);
        border-collapse: collapse;
      }
      #edit-table th {
        background-color: var(--header-color);
      }
      #edit-table td,
      #edit-table th {
        border: solid 1px var(--border-color);
        text-align: left;
      }
      #edit-table th:nth-child(2),
      #edit-table td:nth-child(2) {
        /* This is hacky; table layout is a disaster. */
        max-width: calc(100vw - 100px);
        overflow: hidden;
        padding: 0 var(--margin);
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      #edit-table a {
        color: var(--link-color);
        cursor: pointer;
        text-decoration: underline;
      }
      #edit-header-checkbox.partial {
        opacity: 0.4;
      }

      #edit-opening-overlay {
        align-items: center;
        backdrop-filter: blur(1px);
        background-color: #0002;
        display: none;
        font-size: 20px;
        height: 100vh;
        justify-content: center;
        left: 0;
        position: fixed;
        top: 0;
        width: 100vw;
        z-index: 1;
      }
      #edit-opening-overlay.visible {
        display: flex;
      }
    </style>
  </head>
  <body>
    <h1>yambs (Yet Another MusicBrainz Seeder)</h1>

    <div id="form-section" class="section">
      <p>
        This is a tool for seeding
        <a href="https://musicbrainz.org/" target="_blank">MusicBrainz</a>
        edits. For more information, see the
        <a href="https://github.com/derat/yambs" target="_blank">repository</a>.
      </p>

      <div class="form-row">
        <label for="form-source-select">Source:</label>
        <select id="form-source-select">
          <option value="text">Text</option>
          <option value="bandcamp">Bandcamp</option>
        </select>
      </div>

      <div id="form-bandcamp-section" class="section">
        <div class="form-row">
          <label for="form-bandcamp-url-input">URL:</label>
          <input
            id="form-bandcamp-url-input"
            type="text"
            placeholder="https://example.bandcamp.com/album/some-album"
          />
        </div>
      </div>

      <div id="form-text-section" class="section">
        <div class="form-row">
          <label for="form-text-format-select">Format:</label>
          <select id="form-text-format-select">
            <option value="csv">CSV</option>
            <option value="tsv">TSV</option>
            <option value="keyval">key=value</option>
          </select>
          <label for="form-text-type-select">Type:</label>
          <select id="form-text-type-select">
            <option value="recording">Recording</option>
            <option value="release">Release</option>
          </select>
        </div>
        <div class="form-row">
          <label for="form-text-set-textarea">
            Values to set on all entities (as "field=value" lines):
          </label>
          <textarea id="form-text-set-textarea"></textarea>
        </div>
        <div class="form-row">
          <label for="form-text-fields-input">Input fields (comma-separated):</label>
          <input id="form-text-fields-input" type="text" />
        </div>
        <div class="form-row">
          <label for="form-text-input-textarea">Input in selected format:</label>
          <textarea id="form-text-input-textarea"></textarea>
        </div>
      </div>

      <div class="button-row">
        <button id="form-generate-button">Generate edits</button>
      </div>
    </div>

    <div id="edit-section" class="section">
      <h2>Seeded MusicBrainz edits</h2>
      <table id="edit-table">
        <thead>
          <tr>
            <th><input id="edit-header-checkbox" type="checkbox" /></th>
            <th>Edit</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="button-row">
        <button id="edit-open-all-button">Open all</button>
        <button id="edit-open-selected-button">Open selected</button>
      </div>
    </div>
    <div id="edit-opening-overlay">Opening editâ€¦</div>
  </body>
  <!-- prettier-ignore -->
  <script>
    // This confuses Prettier and seemingly can't be ignored with "// prettier-ignore",
    // so put it in its own script element.
    const initialEdits = [
      {{- range .Edits}}
      {
        desc: {{.Desc}},
        url: {{.URL}},
        params: [
          {{- range .Params}}
          [{{.Name}}, {{.Value}}],
          {{- end}}
        ],
      },
      {{- end}}
    ];
  </script>
  <script>
    const $ = (id) => document.getElementById(id);

    function createElement(type, parentElement = null, className = null, text = null) {
      const element = document.createElement(type);
      if (parentElement) parentElement.appendChild(element);
      if (className) element.className = className;
      if (text || text === '') element.appendChild(document.createTextNode(text));
      return element;
    }

    // Throws if |res| failed due to the server returning an error status.
    function handleFetchError(res) {
      if (!res.ok) {
        return res.text().then((text) => {
          throw new Error(`${res.status}: ${text}`);
        });
      }
      return res;
    }

    const formSection = $('form-section');
    const formSourceSelect = $('form-source-select');
    const formTextFormatSelect = $('form-text-format-select');
    const formTextTypeSelect = $('form-text-type-select');
    const formGenButton = $('form-generate-button');

    // Updates the state of form-related elements.
    function updateFormState() {
      const sel = formSourceSelect.value;
      for (const source of ['bandcamp', 'text']) {
        const section = $(`form-${source}-section`);
        if (source === sel) section.classList.add('visible');
        else section.classList.remove('visible');
      }
      // TODO: Update placeholder text.
    }

    // Sends form data to the server and returns a promise for an array of objects that can be
    // passed to displayEdits().
    function generateEdits() {
      const body = new FormData();
      // TODO: Set parameters.

      return fetch('edits', { method: 'post', body })
        .then((res) => handleFetchError(res))
        .then((res) => res.json());
    }

    const editPreselect = 5; // number of checkboxes to automatically select
    const editSection = $('edit-section');
    const editHeaderCheckbox = $('edit-header-checkbox');
    const editOpenAllButton = $('edit-open-all-button');
    const editOpenSelButton = $('edit-open-selected-button');
    const editTable = $('edit-table');
    const editCheckboxes = [];
    const editForms = []; // null for GETs
    const editLinks = [];
    let editLastClickIndex = -1; // index of last-clicked edit checkbox

    // Returns a 2-element array with the starting and ending index of the selection range.
    // If there isn't a single range, null is returned.
    function getEditSelectionRange() {
      let start = -1;
      let end = -1;
      for (const [idx, cb] of editCheckboxes.entries()) {
        if (!cb.checked) continue;
        if (start < 0) start = end = idx;
        else if (end === idx - 1) end = idx;
        else return null; // not a continuous range
      }
      return start < 0 ? null : [start, end];
    }

    // Returns the number of selected edit rows.
    const getNumSelectedEdits = () => editCheckboxes.filter((cb) => cb.checked).length;

    // If a continuous range of n rows is selected, advances the selection to the next n rows.
    function advanceEditSelection() {
      const range = getEditSelectionRange();
      if (!range || range[1] === editLinks.length - 1) return;

      const start = range[1] + 1;
      const end = start + (range[1] - range[0] + 1);
      editCheckboxes.forEach((cb, idx) => (cb.checked = idx >= start && idx <= end));
      updateEditState();
    }

    // Updates edit header checkbox state and buttons for the currently-checked checkboxes.
    function updateEditState() {
      editOpenAllButton.disabled = editLinks.length === 0;

      // Update the "Open selected" button's text and disabled state.
      const range = getEditSelectionRange();
      editOpenSelButton.innerText =
        range && range[1] < editLinks.length - 1 ? 'Open selected and advance' : 'Open selected';
      editOpenSelButton.disabled = getNumSelectedEdits() === 0;

      // Make the header checkbox checked if any rows are selected, and translucent if only some of
      // the rows are selected.
      const count = getNumSelectedEdits();
      editHeaderCheckbox.checked = count > 0;
      const partial = count > 0 && count < editCheckboxes.length;
      if (partial) editHeaderCheckbox.classList.add('partial');
      else editHeaderCheckbox.classList.remove('partial');
    }

    // Displays the supplied array of objects describing edits:
    // {
    //   desc: 'Human-readable description',
    //   url: 'https://www.example.org',          // includes params if GET is okay
    //   params: [['k', 'v1'], ['k', 'v2'], ...], // if non-empty, POST is needed
    // }
    function displayEdits(edits) {
      if (edits.length) {
        editSection.classList.add('visible');
        window.setTimeout(() => editSection.scrollIntoView(false /* alignToTop */));
      } else {
        editSection.classList.remove('visible');
      }

      const tbody = editTable.querySelector('tbody');
      while (tbody.firstChild) tbody.removeChild(tbody.lastChild);
      editCheckboxes.length = 0;
      editForms.length = 0;
      editLinks.length = 0;
      editLastClickIndex = -1;

      // Add a row for each edit.
      for (const [idx, edit] of edits.entries()) {
        const tr = createElement('tr', tbody);

        // Add a column containing a checkbox.
        const td1 = createElement('td', tr);
        const cb = createElement('input', td1);
        editCheckboxes.push(cb);
        cb.type = 'checkbox';
        cb.addEventListener('click', (e) => {
          // On shift-click, update the range starting at the last-clicked checkbox.
          if (e.shiftKey && editLastClickIndex >= 0 && editLastClickIndex != idx) {
            const checked = cb.checked;
            const start = Math.min(editLastClickIndex, idx);
            const end = Math.max(editLastClickIndex, idx);
            for (let i = start; i <= end; i++) editCheckboxes[i].checked = checked;
          }
          editLastClickIndex = idx;
          updateEditState();
        });
        if (idx < editPreselect) cb.checked = true;

        // Add a second column containing a link.
        // If this edit requires a POST, also add a form.
        const td2 = createElement('td', tr);
        if (edit.params && edit.params.length) {
          const form = createElement('form', td2);
          editForms.push(form);
          form.action = edit.url;
          form.method = 'post';
          form.target = '_blank';
          for (const p of edit.params) {
            const input = createElement('input', form);
            input.type = 'hidden';
            input.name = p[0];
            input.value = p[1];
          }
        } else {
          editForms.push(null);
        }

        const link = createElement('a', td2, null, edit.desc);
        editLinks.push(link);
        if (!edit.params || !edit.params.length) link.href = edit.url;
        link.target = '_blank';
        link.addEventListener('click', (e) => {
          // If there's a form (because this edit requires a POST), submit it.
          // Otherwise, just let the link perform its default action.
          const f = editForms[idx];
          if (f) {
            f.submit();
            e.preventDefault();
          }
        });
      }
    }

    // Initialize the page.
    (() => {
      // Initialize form-related elements.
      if (!initialEdits.length) {
        formSection.classList.add('visible');
        formSourceSelect.addEventListener('change', updateFormState);
        formTextFormatSelect.addEventListener('change', updateFormState);
        formTextTypeSelect.addEventListener('change', updateFormState);
        updateFormState();

        formGenButton.addEventListener('click', () => {
          const origText = formGenButton.innerText;
          formGenButton.disabled = true;
          formGenButton.innerText = 'Generatingâ€¦';

          generateEdits()
            .then((edits) => {
              console.log(`Got ${edits.length} edit(s)`);
              displayEdits(edits);
            })
            .catch((e) => {
              // TODO: Display the error in the UI.
              console.error(e);
            })
            .finally(() => {
              formGenButton.disabled = false;
              formGenButton.innerText = origText;
            });
        });
      }

      // Initialize edit-related elements.
      editHeaderCheckbox.addEventListener('click', () => {
        editLastClickIndex = -1;
        const empty = getNumSelectedEdits() === 0;
        editCheckboxes.forEach((cb) => (cb.checked = empty));
        updateEditState();
      });
      editOpenSelButton.addEventListener('click', () => {
        editLinks.filter((_, i) => editCheckboxes[i].checked).forEach((a) => a.click());
        advanceEditSelection();
      });
      editOpenAllButton.addEventListener('click', () => {
        for (const a of editLinks) a.click();
      });

      displayEdits(initialEdits);
      updateEditState();

      // If there's a single edit, just open it in the current window.
      if (editLinks.length === 1) {
        if (editForms[0]) editForms[0].target = '_self';
        editLinks[0].target = '_self';
        editLinks[0].click();
        $('opening-overlay').classList.add('visible');
      }
    })();
  </script>
</html>
